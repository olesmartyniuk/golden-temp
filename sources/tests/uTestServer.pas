unit uTestServer;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  SysUtils,
  TestFramework,
  uRemotable,
  System.Types,
  Soap.XSBuiltIns,
  Soap.InvokeRegistry,
  uInterfaces,
  uFactories;

type

  TestAdministrator = class(TTestCase)
    private
      FAdmin: IAdministrator;
    public
      procedure SetUp; override;
      procedure TearDown; override;
    published
      procedure TestGroup;
      procedure TestTeacher;
      procedure TestStudent;
  end;

  TestTeacher = class(TTestCase)
    strict private
      FITeacher: ITeacher;
    public
      procedure SetUp; override;
      procedure TearDown; override;
    published
  end;

  TestStudent = class(TTestCase)
    strict private
      FIStudent: IStudent;
    public
      procedure SetUp; override;
      procedure TearDown; override;
    published
  end;

implementation

procedure TestAdministrator.SetUp;
begin
  Remotable.Host := 'localhost';
  Remotable.Account.Login := 'admin';
  Remotable.Account.Password := '123';
  FAdmin := Remotable.NewAdministrator(Remotable.Host);
end;

procedure TestAdministrator.TearDown;
begin

end;

procedure TestAdministrator.TestGroup;
var
  returnValue, i: Integer;
  group: TGroup;
  groups: TGroups;
begin
  // видалимо всі групи, щоб працювати з порожньою базою
  groups := FAdmin.GroupGet(Remotable.Account);
  for i := Low(groups) to High(groups) do
    FAdmin.GroupDel(Remotable.Account, groups[i].Name);

  group := TGroup.Create;
  try
    // спробуємо додати групу з порожнім іменем
    returnValue := FAdmin.GroupAdd(Remotable.Account, group);
    Check(False, 'Додано групу з порожнім іменем');
  except
    on E: EWrongValue do; // глушимо ексепшен
  end;

  // додамо групу
  group.Name := '4 ПР 2';
  group.Description := 'Програмісти 4 курс';
  returnValue := FAdmin.GroupAdd(Remotable.Account, group);
  group.Id := returnValue;
  Check(group.Id > 0, 'Некоректний ID щойно створеної групи');

  // перевіримо чи додалась група
  groups := FAdmin.GroupGet(Remotable.Account);
  Check(Length(groups) = 1, 'Некоректна кількість груп, повинна бути 1');

  Check(groups[0].Id = returnValue, 'Некоректний ID зчитаної групи');
  Check(groups[0].Name = '4 ПР 2', 'Некоректне імя зчитаної групи');
  Check(groups[0].Description = 'Програмісти 4 курс', 'Некоректний опис зчитаної групи');

  // спробуємо додати групу з такою ж назвою
  try
    FAdmin.GroupAdd(Remotable.Account, group);
    Check(False, 'Додано групу з дублюючою назвою');
  except
    on E: EAlreadyExists do; // глушимо ексепшен
  end;

  // переіменуємо групу і перевіримо
  group.Name := '5 ПР 2';
  group.Description := 'Програмісти 5 курс';
  FAdmin.GroupEdit(Remotable.Account, group);

  groups := FAdmin.GroupGet(Remotable.Account);
  Check(Length(groups) = 1, 'Некоректна кількість груп, повинна бути 1');

  Check(groups[0].Id = returnValue, 'Некоректний ID зчитаної групи');
  Check(groups[0].Name = '5 ПР 2', 'Некоректне імя зчитаної групи');
  Check(groups[0].Description = 'Програмісти 5 курс', 'Некоректний опис зчитаної групи');

  // перевіримо видалення групи
  FAdmin.GroupDel(Remotable.Account, group.Name);
  groups := FAdmin.GroupGet(Remotable.Account);
  Check(Length(groups) = 0, 'Некоректна кількість груп, повинна бути 0');

  // додамо 100 груп і перевіримо, чи коректно записались
  for i := 1 to 100 do
  begin
    group := TGroup.Create;
    group.Name := IntToStr(i);
    group.Description := 'Опис для групи № ' + group.Name;
    returnValue := FAdmin.GroupAdd(Remotable.Account, group);
    Check(returnValue > 0, 'Некоректний ID щойно створеної групи');
  end;

  groups := FAdmin.GroupGet(Remotable.Account);
  Check(Length(groups) = 100, 'Некоректна кількість груп, повинна бути 100');

  for i := Low(groups) to High(groups) do
    Check(groups[i].Description = 'Опис для групи № ' + groups[i].Name, 'Імя групи не входить в опис');

  // почистимо після себе
  for i := Low(groups) to High(groups) do
    FAdmin.GroupDel(Remotable.Account, groups[i].Name);
  groups := FAdmin.GroupGet(Remotable.Account);
  Check(Length(groups) = 0, 'Некоректна кількість груп, повинна бути 0');
end;

procedure TestAdministrator.TestTeacher;
begin

end;

procedure TestAdministrator.TestStudent;
begin
end;

procedure TestTeacher.SetUp;
begin
  // TODO: Initialize
end;

procedure TestTeacher.TearDown;
begin
  FITeacher := nil;
end;

procedure TestStudent.SetUp;
begin
  // TODO: Initialize
end;

procedure TestStudent.TearDown;
begin
  FIStudent := nil;
end;

initialization

// Register any test cases with the test runner
RegisterTest(TestAdministrator.Suite);
RegisterTest(TestTeacher.Suite);
RegisterTest(TestStudent.Suite);

end.
